Wgandalf python bindings
========================


I. About this document

Part II describes the compilation, installation and general usage
of Wgandalf Python bindings.

Part III describes the immediate low level API provided by the
wgdb.so (wgdb.pyd) module. This API (in most cases) directly wraps
functions provided by libwgdb.

Part IV describes the high level API, which is designed for convinience
of usage and is not speed-optimized at the moment (start here if you
just want to know how to put stuff into the database using Python).


II. Compilation and Installation

1. Compiling Python bindings

Python module is not compiled by default. ./configure --with-python
enables the compilation (provided that the configure script is
able to locate the Python.h file in the system. If not, it is
assumed that Python is not properly installed and wgandalf will be
compiled without Python bindings).

When building manually, use the separate scripts in Python directory.
Check that the Python path in compile.sh (compile.bat for Windows)
matches your system.

2. Installation

The high level WGandalf.py module expects to find the compiled wgdb.so
module in the same directory it resides in. To install the modules,
they can be copied to Python site-packages directory manually.

3. Compatibility

Minimum version of Python required: 2.5. Other tested versions: 2.6 stable
series. Python 3 is not tested and unsupported.


III. wgdb.so (wgdb.pyd) module

1. Attaching and deleting a database

FUNCTIONS
    attach_database(shmname='', size=0, local=0)
        Connect to a shared memory database. If the database with the
        given name does not exist, it is created. If local is non-zero,
        the parameter shmname is ignored and the database is created in
        local memory instead.
    
    delete_database(shmname)
        Delete a shared memory database.

    detach_database(db)
        Detach from shared memory database. If the database is in the
        local memory, it is deleted.
    
attach_database() allows keyword arguments. If either database name
or size are omitted, default values are used. Note that the shared memory
name is expected to be converted by strtol().

detach_database() tells the system that the current process is no
longer interested in reading the shared memory. This allows the system
to free the shared memory (applies to SysV IPC model - not Win32).
In case of a local database, the allocated memory is freed on all
systems.

Examples:

>>> a=wgdb.attach_database()
>>> b=wgdb.attach_database("1001")
>>> c=wgdb.attach_database(size=3000000)
>>> d=wgdb.attach_database(size=500000, shmname="9999")
>>> d=wgdb.attach_database(local=1)
>>> wgdb.detach_database(d)

delete_database() takes a single argument. If this is omitted, the
default value will be used.

>>> wgdb.delete_database("1001")
>>> wgdb.delete_database()


2. Exception handling.

wgdb module defines a wgdb.error exception object that can be used in
error handling:

>>> try:
...  a=wgdb.attach_database()
... except wgdb.error, msg:
...  print 'wgdb error'
... except:
...  print 'other error'
... 


3. Creating and manipulating records

FUNCTIONS
    create_record(db, length)
        Create a record with given length.
    
    get_first_record(db)
        Fetch first record from database.
    
    get_next_record(db, rec)
        Fetch next record from database.
    
    get_record_len(db, rec)
        Get record length (number of fields).

    is_record(rec)
        Determine if object is a WGandalf record.
    
db is an object returned by wgdb.attach_database(). rec is an object returned
by get_first_record() or other similar functions that return a record.

Examples:

>>> d=wgdb.attach_database()
...
>>> a=wgdb.create_record(d,5)
>>> a
<WGandalf db record at b6908df8>
>>> b=wgdb.create_record(d,3)
>>> b
<WGandalf db record at b6908e10>
>>> rec=wgdb.get_first_record(d)
>>> wgdb.get_record_len(d,rec)
5
>>> rec
<WGandalf db record at b6908df8>
>>> rec=wgdb.get_next_record(d,rec)
>>> wgdb.get_record_len(d,rec)
3
>>> rec
<WGandalf db record at b6908e10>
>>> rec=wgdb.get_next_record(d,rec)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
wgdb.error: Failed to fetch a record.


4. Writing and reading field contents.

wgdb module handles data type conversion between Python and wgandalf. Field
contents will be converted to Python object when reading data and again encoded
into field data when writing to database.

Currently supported types include: None, int, float, string (regular 0-terminated
string. Raw binary data is not allowed), record.

Setting a field to None is equivalent to clearing the field data. Similarly,
unwritten fields will be returned to Python as containing None.

FUNCTIONS
    get_field(db, rec, fieldnr)
        Get field data decoded to corresponding Python type.
    
    set_field(db, rec, fieldnr, data, encoding)
        Set field value.

    set_new_field(db, rec, fieldnr, data, encoding)
        Set field value (assumes no previous content).
    
db is an object returned by wgdb.attach_database(). rec is an object returned
by get_first_record() or other similar functions that return a record.

Encoding (or field type) is an optional argument. If it is omitted, the
type of the field is determined by the Python type. Following encoding types
are defined by the wgdb module:

  BLOBTYPE
  CHARTYPE      - Python string (length 1, longer is allowed but ignored)
  DATETYPE
  DOUBLETYPE    - default encoding for Python float
  FIXPOINTTYPE  - Python float (small, low precision real numbers)
  INTTYPE       - default encoding for Python int
  NULLTYPE      - Python None
  RECORDTYPE    - wgdb.Record type.
  STRTYPE       - default encoding for Python string
  TIMETYPE
  URITYPE
  XMLLITERALTYPE

Examples:

>>> d=wgdb.attach_database()
...
>>> tmp=wgdb.create_record(d,4)
>>> tmp
<WGandalf db record at b6996e00>
>>> print (wgdb.get_field(d,tmp,0),)
(None,)
>>> wgdb.set_field(d,tmp,0,0)
>>> wgdb.set_field(d,tmp,1,256)
>>> wgdb.set_field(d,tmp,2,78.3345)
>>> wgdb.set_field(d,tmp,3,"hello")
>>> print (wgdb.get_field(d,tmp,0),)
(0,)
>>> print (wgdb.get_field(d,tmp,1),)
(256,)
>>> print (wgdb.get_field(d,tmp,2),)
(78.334500000000006,)
>>> print (wgdb.get_field(d,tmp,3),)
('hello',)
>>> wgdb.set_field(d,tmp,3,None)
>>> print (wgdb.get_field(d,tmp,3),)
(None,)

Example with a field pointing to another record:

>>> tmp=wgdb.create_record(d,4)
>>> n=wgdb.create_record(d,4)
>>> wgdb.set_field(d,tmp,3,n)
>>> wgdb.set_field(d,n,0,1)
>>> uu=wgdb.get_field(d,tmp,3)
>>> uu
<WGandalf db record at b69b3e18>
>>> wgdb.get_field(d,uu,0)
1

Example with using specific encoding:

>>> d=wgdb.attach_database()
>>> tmp=wgdb.create_record(d,1)
>>> wgdb.set_field(d,tmp,0,"Hello")
>>> wgdb.get_field(d,tmp,0)
'Hello'
>>> wgdb.set_field(d,tmp,0,"Hello", wgdb.STRTYPE)
>>> wgdb.get_field(d,tmp,0)
'Hello'
>>> wgdb.set_field(d,tmp,0,"Hello", wgdb.CHARTYPE)
>>> wgdb.get_field(d,tmp,0)
'H'
>>> wgdb.set_field(d,tmp,0,"H", wgdb.FIXPOINTTYPE)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Requested encoding is not supported.


5. Transaction handling

Logical level of transaction handling is provided by the wgdb module. These
functions should guarantee safe concurrent usage, however the method of
providing that concurrency is up to the database engine (in simplest case,
the method is a database level lock).

FUNCTIONS
    end_read(db, lock_id)
        Finish reading transaction.
    
    end_write(db, lock_id)
        Finish writing transaction.
    
    start_read(db)
        Start reading transaction.
    
    start_write(db)
        Start writing transaction.

Parameter lock_id is returned by start_write() and start_read() functions. The
same lock id should be passed to end_write() and end_read() functions,
respectively. Depending on the locking mode used, the id may or may not be
meaningful, but in any case this should be handled by the database itself.

If timeouts are enabled, start_read() and start_write() will raise the
wgdb.error exception upon failure to acquire the lock.

Examples:

>>> d=wgdb.attach_database()
...
>>> l=wgdb.start_write(d)
>>> wgdb.create_record(d, 5)
<WGandalf db record at b6981e00>
>>> wgdb.end_write(d,l)
>>> l=wgdb.start_read(d)
>>> wgdb.get_first_record(d)   
<WGandalf db record at b6981e00>
>>> wgdb.end_read(d,l)


6. Date and time fields.

Wgandalf uses a compact encoding for date and time values, which is translated
to and from Python datetime representation on the wgdb module level. See
Python datetime module documentation for more information on how to construct
and use date and time objects.

Note that tzinfo field of the time object and general timezone awareness
supported by the datetime module is ignored on wgdb module level. In practical
applications, it's recommended to treat all time fields as UTC or local time.

Examples:

>>> import wgdb
>>> import datetime
>>> d=wgdb.attach_database()
>>> tmp=wgdb.create_record(d,1)
>>> a=datetime.date(1990,1,2)
>>> wgdb.set_field(d,tmp,0,a)
>>> x=wgdb.get_field(d,tmp,0)
>>> x
datetime.date(1990, 1, 2)
>>> x.day
2
>>> x.month
1
>>> x.year
1990
>>> b=datetime.time(12,05)
>>> wgdb.set_field(d,tmp,0,b)
>>> x=wgdb.get_field(d,tmp,0)
>>> x
datetime.time(12, 5)
>>> x.hour
12
>>> x.minute
5
>>> x.second
0
>>> x.microsecond
0


IV. WGandalf.py module (high level API)

1. Overview

High level access to database is provided by WGandalf.py module. This
module requires the low level wgdb.so (wgdb.pyd on Windows) module.

CLASSES
    Connection
    Cursor
    Record
    wgdb.error(exceptions.StandardError)
        DatabaseError
            DataError
            InternalError
            ProgrammingError
    
    class Connection
     |  The Connection class acts as a container for
     |  wgdb.Database and provides all connection-related
     |  and record accessing functions.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, shmname=None, shmsize=0)
     |  
     |  close(self)
     |      Close the connection.
     |  
     |  commit(self)
     |      Commit the transaction (no-op)
     |  
     |  create_record(self, size)
     |      Create new record with given size.
     |  
     |  cursor(self)
     |      Return a DBI-style database cursor
     |  
     |  end_read(self)
     |      Finish reading transaction
     |  
     |  end_write(self)
     |      Finish writing transaction
     |  
     |  first_record(self)
     |      Get first record from database.
     |  
     |  get_field(self, rec, fieldnr)
     |      Return data field contents
     |  
     |  next_record(self, rec)
     |      Get next record from database.
     |  
     |  rollback(self)
     |      Roll back the transaction (no-op)
     |  
     |  set_field(self, rec, fieldnr, data, enc=0)
     |      Set data field contents
     |  
     |  set_new_field(self, rec, fieldnr, data, enc=0)
     |      Set data field contents (assumes no previous content)
     |  
     |  set_locking(self, mode)
     |      Set locking mode (1=on, 0=off)
     |  
     |  start_read(self)
     |      Start reading transaction
     |  
     |  start_write(self)
     |      Start writing transaction
    
    class Cursor
     |  Pseudo-cursor object. Since there are no queries
     |  available, this allows fetching from the set of all records
     |  and inserting records.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, conn)
     |  
     |  close(self)
     |      Close the cursor
     |  
     |  fetchall(self)
     |      Fetch all (remaining) records from database
     |  
     |  fetchone(self)
     |      Fetch the next record from database
     |  
     |  insert(self, fields)
     |      Insert a record into database
    
    class DataError(DatabaseError)
     |  Exception class to indicate invalid data passed to the db adapter
    
    class DatabaseError(wgdb.error)
     |  Base class for database errors
    
    class InternalError(DatabaseError)
     |  Exception class to indicate invalid internal state of the module
    
    class ProgrammingError(DatabaseError)
     |  Exception class to indicate invalid database usage
    
    class Record
     |  Record data representation. Allows field-level and record-level
     |  manipulation of data.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, conn, rec)
     |  
     |  fetch(self)
     |      Return the contents of the record as tuple
     |  
     |  get__rec(self)
     |      Return low level record object
     |  
     |  get_field(self, fieldnr)
     |      Return data field contents
     |  
     |  get_size(self)
     |      Return record size
     |  
     |  set_field(self, fieldnr, data, enc=0)
     |      Set data field contents with optional encoding
     |  
     |  update(self, fields)
     |      Set the contents of the entire record

FUNCTIONS
    connect(shmname=None, shmsize=0, local=0)
        Attaches to (or creates) a database. Returns a database object

Examples:

Connecting to database with default parameters (see examples for
wgdb.attach_database() for possible arguments and their usage).

>>> import WGandalf
>>> d=WGandalf.connect()

Cursor methods. At first the record set will be emtpy, then we
insert one which is subsequently returned by fetchall().

>>> c=d.cursor()
>>> c.fetchall()
[]
>>> c.insert(("This", "is", "my", 1.0, "record"))
<WGandalf.Record instance at 0xb74a89ac>
>>> c.fetchall()
[('This', 'is', 'my', 1.0, 'record')]

Record methods. We create a new record, then attempt to modify
a single field and the full record. The last attempt will fail
because record size is fixed.

>>> new=c.insert(('My', 2, 'record'))
>>> new
<WGandalf.Record instance at 0xb74a8a8c>
>>> del c
>>> c=d.cursor()
>>> c.fetchall()
[('This', 'is', 'my', 1.0, 'record'), ('My', 2, 'record')]
>>> new.get_field(1)
2
>>> new.set_field(1, 2.0)
>>> new.fetch()
('My', 2.0, 'record')
>>> new.update(('this','will','not','fit'))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "WGandalf.py", line 179, in update
    self.set_field(i, fields[i])
  File "WGandalf.py", line 164, in set_field
    raise Exception, "Field number out of bounds."
Exception: Field number out of bounds.
>>> new.fetch()
('this', 'will', 'not')

Connections can be closed, after which the cursors and records created
using that connection will no longer be usable.

>>> d.close()
>>> new.fetch()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "WGandalf.py", line 171, in fetch
    result.append(self.get_field(i))
  File "WGandalf.py", line 159, in get_field
    return self._conn.get_field(self, fieldnr)
  File "WGandalf.py", line 91, in get_field
    return wgdb.get_field(self._db, rec.get__rec(), fieldnr)
TypeError: argument 1 must be wgdb.Database, not None


2. Linked records

WGandalf record fields may contain references to other records. In high
level API, these records are represented as instances of WGandalf.Record
class. Note that it is not useful to create such instances directly. Instances
of Record class are always returned by WGandalf operations (creating new
records or retrieving existing ones).

Example of linking to other records:

>>> import WGandalf
>>> d=WGandalf.connect()
>>> c=d.cursor()
>>> rec=c.insert((1,2,3,4,5))
>>> c.fetchone()
(1, 2, 3, 4, 5)
>>> c.insert(('1st linked record', rec))
<WGandalf.Record instance at 0xb7543d0c>
>>> c.insert(('2nd linked record', rec))
<WGandalf.Record instance at 0xb7543d2c>
>>> l=c.fetchall()
>>> l
[('1st linked record', <WGandalf.Record instance at 0xb7543d4c>), ('2nd linked record', <WGandalf.Record instance at 0xb7543d6c>)]
>>> map(lambda x: x[1].fetch(), l)
[(1, 2, 3, 4, 5), (1, 2, 3, 4, 5)]
>>> rec.set_field(3, 99)
>>> map(lambda x: x[1].fetch(), l)
[(1, 2, 3, 99, 5), (1, 2, 3, 99, 5)]


3. Transaction support

Transactions are handled internally by the WGandalf module. By default the
concurrency support is turned on and each database read or write is treated
as a separate transaction. The user can turn this behaviour on and off (when there
is a single database user, there will be a small performance gain with locking
turned off).

Turning locking (or transactional) mode off:

>>> d=WGandalf.connect()
>>> d.set_locking(0)

Turning it back on:

>>> d.set_locking(1)


4. Specifying field encoding.

The user can explicitly state which encoding should be used when writing data
to the database. Examples of encodings where this is useful are 1-character
strings and small fixed-point numbers. When encoded as such they consume less
storage space in database and may speed up access as well.

Allowed types are listed under section III.4, "Writing and reading field
contents".

Specific encoding can only be used through Connection.set_field() and
Record.set_field() methods. It is not provided for methods that operate
on the entire record.

Example:

>>> import WGandalf
>>> d=WGandalf.connect()
>>> c=d.cursor()
>>> r=c.insert((None,))
>>> r.set_field(0,"Hello")
>>> r.fetch()
('Hello',)
>>> r.set_field(0,"Hello",WGandalf.wgdb.STRTYPE)
>>> r.fetch()
('Hello',)
>>> r.set_field(0,"Hello",WGandalf.wgdb.CHARTYPE)
>>> r.fetch()
('H',)
>>> r.set_field(0,"Hello",WGandalf.wgdb.INTTYPE)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "WGandalf.py", line 280, in set_field
    return self._conn.set_field(self, fieldnr, data, enc)
  File "WGandalf.py", line 205, in set_field
    r = wgdb.set_field(self._db, rec.get__rec(), fieldnr, data, enc)
TypeError: Requested encoding is not supported.


5. Using dates and times.

Date and time support is implemented using the datetime module included
with the standard Python distribution. Storing a datetime.date object
in the database creates a Wgandalf date type field, similarly a datetime.time
object is stored as a time field. When reading the database, low-level
wgdb module converts the times and dates to datetime.date/time instances
again.

Timezones are not supported through the wgdb API, so timezone-awareness
should be implemented on the application level, if needed.

Date and time fields combined can be used to construct datetime data.

Example:

>>> import WGandalf
>>> import datetime
>>> d=WGandalf.connect()
>>> c=d.cursor()
>>> a=datetime.date(2010,3,31)
>>> b=datetime.time(12,59,microsecond=330000)
>>> rec=c.insert((a,b))
>>> rec.fetch()
(datetime.date(2010, 3, 31), datetime.time(12, 59, 0, 330000))
>>> rec.fetch()[0].month
3
>>> rec.fetch()[1].hour
12

Example of using combined date and time fields as a datetime
object (continuing previous example):

>>> x=apply(datetime.datetime.combine, rec.fetch())
>>> x
datetime.datetime(2010, 3, 31, 12, 59, 0, 330000)
>>> x.strftime("%d.%m.%Y")
'31.03.2010'
>>> x.ctime()
'Wed Mar 31 12:59:00 2010'
