Locking in wgandalf
======================


1. Overview

Concurrency control in wgandalf is achieved using a single
database-level shared/exclusive lock. It is implemented independently
of the rest of the db API (currently) - therefore use of the locking
routines does not automatically guarantee isolation.

Generally, a database level lock is characterized by very low overhead
but maximum possible contention. This means that processes should spend
as little time between acquiring a lock and releasing it, as possible.

2. Implementation and current limitations

There are two alternative implementations.

-  Simple reader-preference lock using a single global spinlock
   (described by Mellor-Crummey & Scott '92). Reader-preference
   means that this lock can cause writer starvation. Tests have
   shown good performance under N>>P conditions (N- number of
   processes, P- number of CPU-s).

-  Locally spinning queued locks (Mellor-Crummey & Scott '92).
   This algorithm serves processes in the order they have requested
   locks, therefore eliminating writer starvation. Also, potentially
   there is less contention between CPU-s in accessing spinlocks,
   since each process has a private spinlock. However, this algorithm
   does not perform well if N>P currently.

Current limitations:

- dead processes hold locks indefinitely.
- there are no timeouts when trying to acquire locks.

3. Configuration

By default, wgandalf is compiled with simple global spinlock. Configuring
with --enable-queued-locks enables the second algorithm.

When using manual build (including Windows), the queued locks algorithm
can be enabled by defining QUEUED_LOCKS in the config.h (or config-w32.h)
header file.

For plaforms that do not support the atomic operations, DUMMY_LOCKS can
be defined via ./configure --enable-dummy-locks or by editing an appropriate
config-xxx.h file. This will allow the code to compile correctly, but the
database should be used by a single user or process only.

4. Usage

Getting a shared (read) lock:

wg_int lock_id;
void *db; /* should be initialized before calling wg_start_read() */

...

/* acquire lock. This function normally blocks until the lock
 * is aquired
 */
lock_id = wg_start_read(db);
if(!lock_id) {
  /* getting the lock failed, do something */
} else {

... one or more database reads ...

/* release the lock */
if(!wg_end_read(db, lock_id)) {
  /* this is unlikely to fail, but if it does, the consequenses
   * could be severe, so this error should also be handled. */
}
}


Getting an exclusive (write) lock is similar:

wg_int lock_id;

...

/* acquire lock. */
lock_id = wg_start_write(db);
if(!lock_id) {
  /* getting the lock failed, do something */
} else {

... one or more database write operations ...

/* release the lock */
if(!wg_end_write(db, lock_id)) {
  /* handle error */
}
}

5. Porting

For platforms that do not support either GNU C or Win32 builtin functions
that implement the atomic operations in dblock.c, appropriate code should
be added to each of the platform-specific helper functions.

The macro _MM_PAUSE can generally be defined as empty on platforms that
do not support Pentium 4/Athlon64-specific "pause" instruction. This will not
have a significant effect (or in other words, the "pause" instruction is
only actually useful on aforementioned processor families).
